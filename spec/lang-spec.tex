\documentclass[10pt]{article}

% Lines beginning with the percent sign are comments
% This file has been commented to help you understand more about LaTeX

% DO NOT EDIT THE LINES BETWEEN THE TWO LONG HORIZONTAL LINES

%---------------------------------------------------------------------------------------------------------

% Packages add extra functionality.
\usepackage{
	times,
	graphicx,
	epstopdf,
	fancyhdr,
	amsfonts,
	amsthm,
	amsmath,
	algorithm,
	algorithmic,
	xspace,
	hyperref,
	comment}
\usepackage[left=1in,top=1in,right=1in,bottom=1in]{geometry}
\usepackage{sect sty}	%For centering section headings
\usepackage{enumerate}	%Allows more labeling options for enumerate environments 
\usepackage{epsfig}
\usepackage[space]{grffile}
\usepackage{booktabs}
\usepackage{amsmath}
\usepackage[super]{nth}
\usepackage{array}

% This will set LaTeX to look for figures in the same directory as the .tex file
\graphicspath{.} % The dot means current directory.

\pagestyle{fancy}

\lhead{\YOURID}
\chead{\MyLang: Language Specification}
\rhead{\today}
\lfoot{CSCI 334: Principles of Programming Languages}
\cfoot{\thepage}
\rfoot{Spring 2022}

% Some commands for changing header and footer format
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\headwidth}{\textwidth}
\renewcommand{\footrulewidth}{0.4pt}

% These let you use common environments
\newtheorem{claim}{Claim}
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{observation}{Observation}
\newtheorem{question}{Question}

\setlength{\parindent}{0cm}
%---------------------------------------------------------------------------------------------------------

% DON'T CHANGE ANYTHING ABOVE HERE

% Edit below as instructed
\newcommand{\MyLang}{G$\flat$}
\newcommand{\PartnerOne}{Ezra Joffe-Hancock}
\newcommand{\PartnerTwo}{Zach Stein-Perlman}
\newcommand{\YOURID}{\PartnerOne{} + \PartnerTwo{}}


\title{\MyLang: Language Specification}
\date{Spring 2022}
\author{\PartnerOne{} and \PartnerTwo{}}

\begin{document}
\maketitle

\vspace{\baselineskip}

\section{Introduction}
Ezra plays alto sax in a jazz combo here, and when he's struggling with soloing over certain songs, it helps him to run over the chord changes and play along with the recording, but the best is when there's a backing track on YouTube, so he can play along with the chords without drowning whoever is soloing on the recording.

We created a language that makes it easy to quickly create a backing track to play over. The programmer creates sections of music by arranging chords and choosing their durations, then describes how many times and in what order to play each section. The output is
% a simple chart with the chord names along a musical bar notation of the song, and ideally a matching audio output (that keeps looping).
a corresponding audio file, or at least an xml file that describes audio.


\section{Design Principles}
The language is simple and accessible for a non-technical user. The syntax is natural.
% and has built in functions and support for common musical terminology
The order of commands makes programs easily readable with intuitive layout. Simplicity is prioritized (worse is better!). A valid program is ideally easy to read and facilitates quickly understanding the music that it describes.


\section{Example Programs}
Example 1:
\begin{verbatim}
let Chorus = {
Cmaj 1
Fmaj 1
Cmaj 1
Gmin 1
Cmaj 4
}

play Chorus 2
\end{verbatim}

Example 2:
\begin{verbatim}
let Chorus = {
Emaj 2
G#maj 2
Bmaj 2
Emaj 4
}

play Chorus 2
\end{verbatim}

Example 3:
\begin{verbatim}
let Intro = {
Cmaj 2
}

let Chorus = {
Gmaj 1
Gmin 1
}

play Intro 1 Chorus 10 Intro 1
\end{verbatim}

\section{Language Concepts}
In order to program in the language, a user should understand the sounds/names of different instruments, have a basic understanding of chords (so they can specify them by writing out their letters), an understanding of a bar/measure which is a grouping of several beats of music. They should understand also how to transfer information from a written piece of sheet music with chords to information within the language, by copying down chords and putting them loops for the appropriate bars. We hope to also provide specifiers like volume, and tempo, so a user should understand how those qualities would affect the output. 


\section{Syntax}
Programs have two parts: defining sections and playing them. When defining a section, we give the name of the section and the chords it comprises. To play, we use its name and the number of times we want to play it.

\begin{verbatim}
<expr>       ::= <assignments> <play>
<assignments>::= <assignment>+
<assignment> ::= <section> <variable>
<section>    ::= <sound>+
<sound>      ::= <chord> <ws> <int>
<chord>      ::= <note> <ws> <quality>
<ws>         ::= ␣
<note>       ::= A | A# | Bb | B | C | C# | Db | D | D# | Eb | E | F | F# 
               | Gb | G | G# | Ab
<quality>    ::= Maj | Min
<variable>   ::= <string>
<play>       ::= (<variable> <int>)+
\end{verbatim}

\section{Semantics}
\begin{enumerate}[i]
\item What are the primitive kinds of values in your system? One kind of primitive value in our language are notes, which are of type char and are later converted using some sort of dictionary structure into either floats representing note frequencies, or directly to audio samples.

Another primitive are integers, which are used to define the values of volume, tempo, bars range, and number of repeats of sections. Chords are a primitive and are a list of notes, and are created by interpreting a the name of a chord into its component notes according to some function that operates according to the rules of music theory. 

\begin{center}
\begin{tabular}{c|p{2.5cm}|p{3cm}|c|p{4cm}} 
Syntax & Abstract syntax & Type & Prec./Assoc. & Meaning \\ [0.5ex] 
\hline
%  ``Piano" & Piano & Instrument & n/a & The type of instrument playing a given chord \\ \hline
F\# & Note & string & n/a & A note \\ \hline
Cmaj & Quality of Note & string → Chord & n/a & A chord to be played where C stands for the note and maj for the quality \\ \hline
% & Quality/Chord &  & n/a &  \\ \hline
Cmaj 1 & Sound of Chord * int & (Chord * int) → Sound & n/a & A chord and its duration \\ \hline
sound1 ... soundn & Section of Sound list & Sound list → Section & n/a & A sequence of sounds \\ \hline
Chorus & Variable of string & string & n/a & The name of a section \\ \hline
let var = \{section\} & Assignment of Section * Variable & (Section * Variable) → Assignment & n/a & A pairing of a section with a name \\ \hline
assign1 ... assignn & Assignments of Assignment list & Assignment list → Assignments & n/a & A list of sections and their associated names \\ \hline
play var1 x1 ... varn xn & Play of (Variable * int) list & (Variable * int) list → Play & n/a & A specification of sections to play \\ \hline
Assignments Play & Program of Assignments * Play & Assignments * Play → Program & n/a & A complete program \\ 
\end{tabular}
\end{center}

\item What are the “actions” or compositional elements of your language? In other words, how are values combined? 

Sections are marked by a ``let sectionName = \{" command and then a series of sounds until the ``\}" command is reached. These sections are then given as input to the play function, which produces the output of a section (a combination of sounds) a given number of times.

\item \begin{enumerate}[A]
        \item Our programs read no input.
        
        \item Our programs output an xml describing audio

\end{enumerate}

\section{Remaining Work}

Necessary data types: all implemented.

Necessary operations: all implemented.

We will add more chord qualities.
\begin{comment}
        | Tonic(note) -> note
        | Maj(note) -> adjust [0;4;7] note
        | Min(note) -> adjust [0;3;7] note
        | Seven(note) -> adjust [0;4;7;10] note
        | MinSeven(note) -> adjust [0;3;7;10] note
        | DimSeven(note) -> adjust [0;3;6;9] note
        | Four(note) -> adjust [0;5;9] note
        | VSeven(note) -> adjust [-1;2;7] note

let pchordquality = (pfresult (pstr "maj") Maj) <|> (pfresult (pstr "M") Maj) <|> (pfresult (pstr "min") Min) <|> (pfresult (pstr "m") Min) <|> (pfresult (pstr "7") Seven) <|> (pfresult (pstr "min7") MinSeven) <|> (pfresult (pstr "dim7") DimSeven) <|> (pfresult (pstr "4") Four) <|> (pfresult (pstr "V7") VSeven) <|> (pfresult (pstr " ") Tonic) <!> "pchordquality"


Example 1:
\begin{verbatim}
let Chorus = {
CM 1
C4 1
CM 1
CV7 1
CM 4
}

play Chorus 2
\end{verbatim}

Example 2:
\begin{verbatim}
let Chorus = {
Emaj 2
G#maj 2
Bmaj 2
Emaj 4
}

play Chorus 2
\end{verbatim}

Example 3:
\begin{verbatim}
let Intro = {
CM 2
}

let Chorus = {
Gmaj 1
Gmin 1
}

play Intro 1 Chorus 10 Intro 1
\end{verbatim}
\end{comment}

We will add slightly more control over tempo.

Possible stretch goals:

- Program correctness checker, including at least case-insensitivity

- Enhance readability of language specification

- Add instruments beyond piano

- Allow more flexible control over tempo, volume, and/or octave

- Pretty printing of musical notation corresponding to the audio

\end{enumerate}


% DO NOT DELETE ANYTHING BELOW THIS LINE
\end{document}
